package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};

terminal PLUS, MINUS, TIMES, LPAREN, RPAREN, RETURN, SEMI, INTTYPE, IF, ELSE, WHILE, LESS_THAN, LESS_THAN_OR_EQUAL_TO, GREATER_THAN, GREATER_THAN_OR_EQUAL_TO, DOUBLE_EQUALS, NOT_EQUALS, BOOL_NOT, BOOL_AND, BOOL_OR, EQUALS;


terminal Long INTCONST;
terminal String IDENT;

non terminal Program         program;
non terminal main            main; 
non terminal varDecl         varDecl;
non terminal type            type;
non terminal stmtList        stmtList;
non terminal stmt            stmt;
non terminal cond            cond;
non terminal Expr            expr;
non terminal BinaryExpr      binaryExpr;


precedence left IF;
precedence left ELSE;
precedence left BOOL_AND, BOOL_OR;
precedence left BOOL_NOT;
precedence left LESS_THAN_OR_EQUAL_TO, GREATER_THAN_OR_EQUAL_TO, DOUBLE_EQUALS, NOT_EQUALS, LESS_THAN, GREATER_THAN;
precedence left PLUS, MINUS;
precedence left TIMES;

start with program;

program ::= varDecl:v LPAREN formalDeclList:fdl RPAREN LBRACE statementList:sl RBRACE
            {: RESULT = new Program(v, fdl, sl, loc(slleft, slright)); :}
         ;


varDecl ::= type:t IDENT:i
            {: RESULT = new VarDecl(t, i); :}
         ;

type ::= INTTYPE
            {: RESULT = VarDecl.INTTYPE;  :}
      ;

formalDeclList ::= neFormalDeclList:nefdl
         {: RESULT = nefdl; :}
      | /* epsilon */
         {: RESULT = new ArrayList<VarDecl>(); :}
      ;

neFormalDeclList ::= varDecl:v COMMA neFormalDeclList:nefdl
         {: nefdl.add(0, v); RESULT = nefdl; :}
      | varDecl:v
         {: List<VarDecl> formalDeclarations = new ArrayList<VarDecl>(); formalDeclarations.add(0, v); RESULT = formalDeclarations; :}
      ;

stmtList ::= stmt:s stmtList:sl
         {: sl.add(0, s); RESULT = sl; :}
      |  /* epsilon */
         {: RESULT = new ArrayList<Statement>(); :}
      ;


stmt ::= RETURN expr:e SEMI
            {: RESULT = new ReturnStatement(e, loc(eleft, eright)); :}
      |  varDecl:vd EQUALS expr:e SEMI
            {: RESULT = new VarDeclareStatement(vd, e, loc(vleft, vright)); :}
      |  IF cond:c stmt:s
            {: RESULT = new IfStatement(c, s, loc(cleft, cright)); :}
      |  IF cond:c stmt:s ELSE stmt:s
            {: RESULT = new IfElseStatement(c, s1, elseS, loc(cleft, cright)); :}
      |  PRINT expr:e SEMI
            {: RESULT = new PrintStatement(e, loc(eleft, eright)); :}
      | LCURLY stmtList:sl RCURLY
            {: RESULT = new StatementList(sl, loc(slleft, slright)); :}
      ;

cond ::= expr:c1 LESS_THAN_OR_EQUAL_TO expr:c2
         {: RESULT = new CondEval(c1, CondEval.LESS_THAN_OR_EQUAL_TO, c2, loc(c1left, c1right)); :}
      |  expr:c1 GREATER_THAN_OR_EQUAL_TO expr:c2
         {: RESULT = new CondEval(c1, CondEval.GREATER_THAN_OR_EQUAL_TO, c2, loc(c1left, c1right)); :}
      |  expr:c1 DOUBLE_EQUALS expr:c2
         {: RESULT = new CondEval(c1, CondEval.DOUBLE_EQUALS, c2, loc(c1left, c1right)); :}
      |  expr:c1 NOT_EQUALS expr:c2
         {: RESULT = new CondEval(c1, CondEval.NOT_EQUALS, c2, loc(c1left, c1right)); :}
      |  expr:c1 LESS_THAN expr:c2
         {: RESULT = new CondEval(c1, CondEval.LESS_THAN, c2, loc(c1left, c1right)); :}
      |  expr:c1 GREATER_THAN expr:c2
         {: RESULT = new CondEval(c1, CondEval.GREATER_THAN, c2, loc(c1left, c1right)); :}
      |  cond:c1 BOOL_AND cond:c2
         {: RESULT = new AndOR(c1, AndOR.BOOL_AND, c2, loc(c1left, c1right)); :}
      |  cond:c1 BOOL_OR cond:c2
         {: RESULT = new AndOR(c1, AndOR.BOOL_OR, c2, loc(c1left, c1right)); :}
      |  BOOL_NOT cond:c
         {: RESULT = new NotOP(NotOP.BOOL_NOT, c, loc(cleft, cright)); :}
      |  LPAREN cond:c RPAREN
         {: RESULT = c; :}
      ;

      
      
      
      

expr ::= INTCONST:c
         {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
      |  binaryExpr:e
         {: RESULT = e; :}
      |  LPAREN expr:e RPAREN
         {: RESULT = e; :}
      |  MINUS expr:e
         {: RESULT = new UnaryExpr(e,loc(eleft, eright));:}
      |  IDENT:i
         {: :}
      ;

binaryExpr ::= expr:e1 PLUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MINUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 TIMES expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.TIMES, e2, loc(e1left, e1right)); :}
            ;
